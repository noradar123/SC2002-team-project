package entity;

import java.io.FileWriter;
import java.io.IOException;
import java.time.LocalDate;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * Represents a statistical report generated by Career Center Staff.
 * This entity aggregates internship data to provide insights into the system's status
 * (e.g., number of pending, approved, or filled positions).
 */
public class Report {

    private String reportID;
    private CareerCenterStaff generatedBy;
    private LocalDate generationDate;   // <-- MATCHES UML
    private List<Internship> includedOpportunities;

    /**
     * Constructs a new Report.
     *
     * @param reportID              The unique identifier for the report.
     * @param generatedBy           The staff member who generated the report.
     * @param generationDate        The date the report was created.
     * @param includedOpportunities The list of internships included in the analysis.
     */
    public Report(String reportID, CareerCenterStaff generatedBy,
                  LocalDate generationDate, List<Internship> includedOpportunities) {
        this.reportID = reportID;
        this.generatedBy = generatedBy;
        this.generationDate = generationDate;
        this.includedOpportunities = new ArrayList<>(includedOpportunities);
    }

    /**
     * Gets the unique report ID.
     * @return The report ID string.
     */
    public String getReportID() {
        return reportID;
    }

    /**
     * Gets the staff member who generated this report.
     * @return The CareerCenterStaff object.
     */
    public CareerCenterStaff getGeneratedBy() {
        return generatedBy;
    }

    /**
     * Gets the date this report was generated.
     * @return The generation date.
     */
    public LocalDate getGenerationDate() {
        return generationDate;
    }

    /**
     * Retrieves the list of internships included in this report.
     * @return A new list containing the internship objects (defensive copy).
     */
    public List<Internship> getIncludedOpportunities() {
        return new ArrayList<>(includedOpportunities);
    }

    /**
     * Prints a textual summary of the report to the console.
     * Includes metadata (ID, Author) and a breakdown of internship statuses.
     */
    public void displaySummary() {
        System.out.println("=== INTERNSHIP REPORT SUMMARY ===");
        System.out.println("Report ID: " + reportID);
        System.out.println("Generated by: " + generatedBy.getName());
        System.out.println("Generated on: " + generationDate);
        System.out.println("Total Opportunities: " + includedOpportunities.size());

        long pending = includedOpportunities.stream().filter(i -> i.getStatus().name().equals("PENDING")).count();
        long approved = includedOpportunities.stream().filter(i -> i.getStatus().name().equals("APPROVED")).count();
        long rejected = includedOpportunities.stream().filter(i -> i.getStatus().name().equals("REJECTED")).count();
        long filled = includedOpportunities.stream().filter(i -> i.getStatus().name().equals("FILLED")).count();

        System.out.println("\nStatus Breakdown:");
        System.out.println("Pending: " + pending);
        System.out.println("Approved: " + approved);
        System.out.println("Rejected: " + rejected);
        System.out.println("Filled: " + filled);
    }

    /** * Computes detailed statistics for the included internships.
     * Calculates counts for each status (PENDING, APPROVED, REJECTED, FILLED)
     * and their respective percentages.
     *
     * @return A map containing statistical keys (Strings) and values (Integers for counts, Doubles for percentages).
     */
    public Map<String, Object> getStatistics() {
        Map<String, Object> stats = new HashMap<>();
        int total = includedOpportunities.size();

        long pending = includedOpportunities.stream().filter(i -> i.getStatus().name().equals("PENDING")).count();
        long approved = includedOpportunities.stream().filter(i -> i.getStatus().name().equals("APPROVED")).count();
        long rejected = includedOpportunities.stream().filter(i -> i.getStatus().name().equals("REJECTED")).count();
        long filled = includedOpportunities.stream().filter(i -> i.getStatus().name().equals("FILLED")).count();

        stats.put("Total Opportunities", total);
        stats.put("Pending", pending);
        stats.put("Approved", approved);
        stats.put("Rejected", rejected);
        stats.put("Filled", filled);

        if (total > 0) {
            stats.put("Approved %", approved * 100.0 / total);
            stats.put("Rejected %", rejected * 100.0 / total);
            stats.put("Filled %", filled * 100.0 / total);
        }

        return stats;
    }

    /**
     * Exports the full report and statistics to a text file.
     *
     * @param filePath The file system path where the report should be saved.
     * @return {@code true} if the file was written successfully; {@code false} if an I/O error occurred.
     */
    public boolean exportToFile(String filePath) {
        try (FileWriter writer = new FileWriter(filePath)) {

            writer.write("=== Internship Report ===\n");
            writer.write("Report ID: " + reportID + "\n");
            writer.write("Generated by: " + generatedBy.getName() + "\n");
            writer.write("Date: " + generationDate + "\n\n");

            writer.write("=== Included Opportunities ===\n");
            for (Internship i : includedOpportunities) {
                writer.write(i.toString() + "\n");
                writer.write("Company: " + i.getCompany() + "\n");
                writer.write("Status: " + i.getStatus() + "\n");
                writer.write("-----------------------------\n");
            }

            writer.write("\n=== Summary Statistics ===\n");
            Map<String, Object> stats = getStatistics();
            for (Map.Entry<String, Object> entry : stats.entrySet()) {
                writer.write(entry.getKey() + ": " + entry.getValue() + "\n");
            }

            writer.flush();
            return true;

        } catch (IOException e) {
            System.err.println("Error exporting report: " + e.getMessage());
            return false;
        }
    }
}